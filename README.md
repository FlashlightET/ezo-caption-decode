# ezo-caption-decode
Crude caption decoding

Code is extremely ugly and some variable names are effectively obfuscated from hasty writing.

First, DataStreams.py takes (a) line(s) from a --luma-4fsc TBC video export and creates PNG waterfalls of those lines. 40 (field 1 line 20, zero-indexed) is usually the "line 21" that captions are stored on. Likewise, if i remember correctly, 20 (field 0 line 20, zero-indexed) is the "line 21" that XDS is stored on.

Second, decode_cc_from_waterfall_2_alt.py takes a waterfall generated by DataStreams.py and does the actual decoding work on it. At some point I'll add back in the caption display emulation code that was partially hacked out for the Hot Springs SRT captions. 

CC/XDS decoding is agnostic. You do not have to specify if you're decoding CC or XDS because those have their own starting bytes regardless. You won't normally find XDS on the caption stream (40, CC2), but you can sometimes find captions on the XDS stream (20, CC1).

When it decodes XDS it would show onscreen with the display emulation code:

![XDS example](https://github.com/FlashlightET/ezo-caption-decode/assets/29938499/7f77dc2e-53d4-49b3-a11f-47e48b196e5e)

but normally (and currently only) decodes into JSON (which isn't yet saved). Something along the lines of...

```json
{
    "nul":"                                ",
    "end":"                                ",
    "Station.CallLetters": "TBS     ", 
    "Station.StationName":"Turner Broadcasting System        ",
    "Current.ProgramID":"                                ",
    "Current.ProgramLength":"                                ",
    "Current.ProgramName":"NOW AND THEN                    ",
    "Current.ProgramType":"Entertainment   "
    }
```

...with fields dynamically added depending on received packets.
